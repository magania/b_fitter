 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooAngle.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include <math.h> 
 #include "TMath.h" 

 //ClassImp(RooAngle) 

 RooAngle::RooAngle(const char *name, const char *title, 
                        RooAbsReal& _cpsi,
                        RooAbsReal& _ctheta,
                        RooAbsReal& _phi,
                        RooAbsReal& _e01m1,
                        RooAbsReal& _e01p0,
                        RooAbsReal& _e01p1,
                        RooAbsReal& _e02m2,
                        RooAbsReal& _e02m1,
                        RooAbsReal& _e02p0,
                        RooAbsReal& _e02p1,
                        RooAbsReal& _e02p2,
                        RooAbsReal& _e20p0,
                        RooAbsReal& _e21m1,
                        RooAbsReal& _e21p0,
                        RooAbsReal& _e21p1,
                        RooAbsReal& _e22m2,
                        RooAbsReal& _e22m1,
                        RooAbsReal& _e22p0,
                        RooAbsReal& _e22p1,
                        RooAbsReal& _e22p2) :
   RooAbsPdf(name,title), 
   cpsi("cpsi","cpsi",this,_cpsi),
   ctheta("ctheta","ctheta",this,_ctheta),
   phi("phi","phi",this,_phi),
   e01m1("e01m1","e01m1",this,_e01m1),
   e01p0("e01p0","e01p0",this,_e01p0),
   e01p1("e01p1","e01p1",this,_e01p1),
   e02m2("e02m2","e02m2",this,_e02m2),
   e02m1("e02m1","e02m1",this,_e02m1),
   e02p0("e02p0","e02p0",this,_e02p0),
   e02p1("e02p1","e02p1",this,_e02p1),
   e02p2("e02p2","e02p2",this,_e02p2),
   e20p0("e20p0","e20p0",this,_e20p0),
   e21m1("e21m1","e21m1",this,_e21m1),
   e21p0("e21p0","e21p0",this,_e21p0),
   e21p1("e21p1","e21p1",this,_e21p1),
   e22m2("e22m2","e22m2",this,_e22m2),
   e22m1("e22m1","e22m1",this,_e22m1),
   e22p0("e22p0","e22p0",this,_e22p0),
   e22p1("e22p1","e22p1",this,_e22p1),
   e22p2("e22p2","e22p2",this,_e22p2)
 { 
 } 


 RooAngle::RooAngle(const RooAngle& other, const char* name) :  
   RooAbsPdf(other,name), 
   cpsi("cpsi",this,other.cpsi),
   ctheta("ctheta",this,other.ctheta),
   phi("phi",this,other.phi),
   e01m1("e01m1",this,other.e01m1),
   e01p0("e01p0",this,other.e01p0),
   e01p1("e01p1",this,other.e01p1),
   e02m2("e02m2",this,other.e02m2),
   e02m1("e02m1",this,other.e02m1),
   e02p0("e02p0",this,other.e02p0),
   e02p1("e02p1",this,other.e02p1),
   e02p2("e02p2",this,other.e02p2),
   e20p0("e20p0",this,other.e20p0),
   e21m1("e21m1",this,other.e21m1),
   e21p0("e21p0",this,other.e21p0),
   e21p1("e21p1",this,other.e21p1),
   e22m2("e22m2",this,other.e22m2),
   e22m1("e22m1",this,other.e22m1),
   e22p0("e22p0",this,other.e22p0),
   e22p1("e22p1",this,other.e22p1),
   e22p2("e22p2",this,other.e22p2)
 { 
 } 

Double_t RooAngle::HarmonicSphericalY(int l, int m) const {
        if (m==0)
                return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l+1))/(4.0*TMath::Pi()*TMath::Gamma(l+1)) )*ROOT::Math::assoc_legendre(l,0,ctheta);
        if (m>0)
                return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l-m+1))/(2.0*TMath::Pi()*TMath::Gamma(l+m+1)) )*ROOT::Math::assoc_legendre(l,m,ctheta)*TMath::Cos(m*phi)*TMath::Power(-1.0,m);
        if (m<0)
                return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l+m+1))/(2.0*TMath::Pi()*TMath::Gamma(l-m+1)) )*ROOT::Math::assoc_legendre(l,-m,ctheta)*TMath::Sin(-m*phi)*TMath::Power(-1.0,-m);
}


 Double_t RooAngle::evaluate() const 
 { 
   return  0.14104739588693907*( (       HarmonicSphericalY(0,0) + 
                                   e01m1*HarmonicSphericalY(1,-1) + e01p0*HarmonicSphericalY(1, 0) + e01p1*HarmonicSphericalY(1,1) + 
                                   e02m2*HarmonicSphericalY(2,-2) + e02m1*HarmonicSphericalY(2,-1) + e02p0*HarmonicSphericalY(2,0) + e02p1*HarmonicSphericalY(2,1) + e02p2*HarmonicSphericalY(2,2)) +
                                 (-0.5+1.5*cpsi*cpsi)*(e20p0*HarmonicSphericalY(0,0) +
                                                       e21m1*HarmonicSphericalY(1,-1) + e21p0*HarmonicSphericalY(1, 0) + e21p1*HarmonicSphericalY(1,1) +
                                                       e22m2*HarmonicSphericalY(2,-2) + e22m1*HarmonicSphericalY(2,-1) + e22p0*HarmonicSphericalY(2,0) + e22p1*HarmonicSphericalY(2,1) + e22p2*HarmonicSphericalY(2,2)));

 }

Int_t RooAngle::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName*/) const
{
  if (matchArgs(allVars, analVars, cpsi, ctheta, phi)) return 1;
  if (matchArgs(allVars, analVars,       ctheta, phi)) return 2;
  if (matchArgs(allVars, analVars, cpsi,         phi)) return 3;
  if (matchArgs(allVars, analVars, cpsi, ctheta     )) return 4;
  if (matchArgs(allVars, analVars, cpsi             )) return 0;
  if (matchArgs(allVars, analVars,       ctheta     )) return 0;
  if (matchArgs(allVars, analVars,               phi)) return 0;

 return 0;
}

Double_t RooAngle::analyticalIntegral(Int_t code, const char* range) const
{
  switch(code){
	case 1:
		return 1;
	case 2:
		return ( 0.5 + 0.25*(-1.0 + 3*cpsi*cpsi)*e20p0 );
	case 3:
		return ( 0.5 + 0.5*TMath::Sqrt(3)*ctheta*e01p0 - 0.25*TMath::Sqrt(5)*e02p0 + 0.75*TMath::Sqrt(5)*ctheta*ctheta*e02p0 );
	case 4:
 		return ( 0.159154943091895 - 0.216506350946110*TMath::Cos(phi)*e01p1 + 0.205468148020500*TMath::Cos(2.0*phi)*e02p2 - 0.216506350946110*e01m1*TMath::Sin(phi) + 0.205468148020500*e02m2*TMath::Sin(2.0*phi) );
  }
  
  cout << "Error in Integral" << endl;
  exit(1);
}
 
