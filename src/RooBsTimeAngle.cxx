 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooBsTimeAngle.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include <math.h> 
 #include "TMath.h"
 #include "RooRandom.h"

 #include "RooComplex.h"
 #include "RooMath.h"

 ClassImp(RooBsTimeAngle) 

 RooBsTimeAngle::RooBsTimeAngle(const char *name, const char *title, 
                        RooAbsReal& _t,
                        RooAbsReal& _et,
                        RooAbsReal& _cpsi,
                        RooAbsReal& _ctheta,
                        RooAbsReal& _phi,
                        RooAbsReal& _D,
                        RooAbsReal& _a0,
                        RooAbsReal& _al,
                        RooAbsReal& _ap,
                        RooAbsReal& _DG,
                        RooAbsReal& _Dm,
                        RooAbsReal& _tau,
                        RooAbsReal& _beta,
                        RooAbsReal& _delta_l,
                        RooAbsReal& _delta_p,
                        RooAbsReal& _delta_s,
                        RooAbsReal& _fs,
                        RooAbsReal& _s) :
   RooAbsPdf(name,title), 
   t("t","t",this,_t),
   et("et","et",this,_et),
   cpsi("cpsi","cpsi",this,_cpsi),
   ctheta("ctheta","ctheta",this,_ctheta),
   phi("phi","phi",this,_phi),
   D("D","D",this,_D),
   a0("a0","a0",this,_a0),
   al("al","al",this,_al),
   ap("ap","ap",this,_ap),
   DG("DG","DG",this,_DG),
   Dm("Dm","Dm",this,_Dm),
   tau("tau","tau",this,_tau),
   beta("beta","beta",this,_beta),
   delta_l("delta_l","delta_l",this,_delta_l),
   delta_p("delta_p","delta_p",this,_delta_p),
   delta_s("delta_s","delta_s",this,_delta_s),
   fs("fs","fs",this,_fs),
   s("s","s",this,_s),
   _aleatorio(0)
 {
 	_resolution = true;
 } 

 RooBsTimeAngle::RooBsTimeAngle(const char *name, const char *title,
                        RooAbsReal& _t,
                        RooAbsReal& _cpsi,
                        RooAbsReal& _ctheta,
                        RooAbsReal& _phi,
                        RooAbsReal& _D,
                        RooAbsReal& _a0,
                        RooAbsReal& _al,
                        RooAbsReal& _ap,
                        RooAbsReal& _DG,
                        RooAbsReal& _Dm,
                        RooAbsReal& _tau,
                        RooAbsReal& _beta,
                        RooAbsReal& _delta_l,
                        RooAbsReal& _delta_p,
                        RooAbsReal& _delta_s,
                        RooAbsReal& _fs) :
   RooAbsPdf(name,title),
   t("t","t",this,_t),
   cpsi("cpsi","cpsi",this,_cpsi),
   ctheta("ctheta","ctheta",this,_ctheta),
   phi("phi","phi",this,_phi),
   D("D","D",this,_D),
   a0("a0","a0",this,_a0),
   al("al","al",this,_al),
   ap("ap","ap",this,_ap),
   DG("DG","DG",this,_DG),
   Dm("Dm","Dm",this,_Dm),
   tau("tau","tau",this,_tau),
   beta("beta","beta",this,_beta),
   delta_l("delta_l","delta_l",this,_delta_l),
   delta_p("delta_p","delta_p",this,_delta_p),
   delta_s("delta_s","delta_s",this,_delta_s),
   fs("fs","fs",this,_fs),
   _aleatorio(0)
 {
 	_resolution = false;
 }


 RooBsTimeAngle::RooBsTimeAngle(const RooBsTimeAngle& other, const char* name) :  
   RooAbsPdf(other,name), 
   t("t",this,other.t),
   et("et",this,other.et),
   cpsi("cpsi",this,other.cpsi),
   ctheta("ctheta",this,other.ctheta),
   phi("phi",this,other.phi),
   D("D",this,other.D),
   a0("a0",this,other.a0),
   al("al",this,other.al),
   ap("ap",this,other.ap),
   DG("DG",this,other.DG),
   Dm("Dm",this,other.Dm),
   tau("tau",this,other.tau),
   beta("beta",this,other.beta),
   delta_l("delta_l",this,other.delta_l),
   delta_p("delta_p",this,other.delta_p),
   delta_s("delta_s",this,other.delta_s),
   fs("fs",this,other.fs),
   s("s",this,other.s),
   _aleatorio(other._aleatorio),
   _resolution(other._resolution)
 { 
 } 


 Double_t RooBsTimeAngle::evaluate() const 
 {
	TComplex Aplus[3], Aminus[3], B[3], xAplusK[2], xAminusK, CDAplusAplusC, CDAplusAminus, CDAplusB, CDAminusB, CDAminusAminusC, CDBBC, Imu ;
	Double_t  P_B, P_Bbar, Q_B, Q_Bbar, rho_B, rho_Bbar, Acceptance, n[3], CDAplusAplus, CDAminusAminus, CDBB;

	/*  Static */
	Aplus[2] = TComplex(0.0, 0.0);

	Aminus[0] = TComplex(0.0, 0.0);
	Aminus[1] = TComplex(0.0, 0.0); 

	B[0] = TComplex::One();   // 8.16
	B[1] = TComplex(0,0);
	B[2] = TComplex(0,0);

	/* A */
	Double_t z=0;
	AplusK(&xAplusK[0], z, z, z);
	AplusK(xAplusK, a0, al, delta_l);
	AminusK(xAminusK, ap, delta_p);

	Aplus[0] = xAplusK[0]*cpsi;
	Aplus[1] = xAplusK[1]*TMath::Sqrt(1.0-cpsi*cpsi);

	Aminus[2] = xAminusK*TMath::Sqrt(1.0-cpsi*cpsi);

	/* nhat */
	nhat(n, ctheta, phi);
	if (__debug) cout << "n = (" << n[0] << ", " << n[1] << ", " << n[2] << ")" << endl;

	/* CrossDot(A,B) = Dot(Cross(A,n),Conjugate(Cross(B,n))) */
	CrossDot(CDAplusAplusC, Aplus, Aplus, n);
	CrossDot(CDAplusAminus, Aplus, Aminus, n);
	CrossDot(CDAminusAminusC, Aminus, Aminus, n);
	CrossDot(CDAplusB,  Aplus, B, n);
	CrossDot(CDAminusB,  Aminus, B, n);
	CrossDot(CDBBC, B, B, n);

	CDAplusAplus = CDAplusAplusC.Re();
	CDAminusAminus = CDAminusAminusC.Re();
	CDBB = CDBBC.Re();

	if (__debug) {
		cout << "CDAplusAplus = " << CDAplusAplus << endl;
		cout << "CDAplusAminus = " << CDAplusAminus << endl;
		cout << "CDAminusAminus = " << CDAminusAminus << endl;
		cout << "CDAplusB = " << CDAplusB << endl;
		cout << "CDAminusB = " << CDAminusB << endl;
		cout << "CDBB = " << CDBB << endl;
	}
	/* f */

	Double_t tauL = 2.0/((2.0/tau)+DG);
	Double_t tauH = 2.0/((2.0/tau)-DG);

	Double_t xC2B = TMath::Cos(2.0*beta);
	Double_t x2S2B = 2.0*TMath::Sin(2.0*beta);
	Double_t x1pC2B = 1.0 + xC2B;
	Double_t x1mC2B = 1.0 - xC2B;

	Double_t Pink, Green, Red, Blue;
	
	if ( !_resolution ) {
		if (t<0 ) {
			Pink = 0;
			Green = 0;
			Red = 0;
			Blue = 0;
		} else {
			Pink  = TMath::Exp(-t/tauL);
			Green = TMath::Exp(-t/tauH);
			Red   = TMath::Exp(-t/tau)*TMath::Sin(Dm*t);
			Blue  = TMath::Exp(-t/tau)*TMath::Cos(Dm*t);
		}
	} else {
		Double_t sigma = s*et;
		Pink  = 0.5*TMath::Exp((sigma*sigma - 2.0*t*tauL)/(2.0*tauL*tauL))*TMath::Erfc((sigma*sigma-t*tauL)/(1.41421356237309515*sigma*tauL));
		Green = 0.5*TMath::Exp((sigma*sigma - 2.0*t*tauH)/(2.0*tauH*tauH))*TMath::Erfc((sigma*sigma-t*tauH)/(1.41421356237309515*sigma*tauH));

		Double_t i0_re = 0.707106781186547462*(t/sigma - sigma/tau);
		Double_t i0_im = -0.707106781186547462*Dm*sigma;

		Double_t w_Exp = 0.25*TMath::Exp(-t*t/(2.0*sigma*sigma));
		RooComplex i0_cerf;
		if (__fast)
			i0_cerf = RooMath::FastComplexErrFunc(RooComplex(-i0_im,i0_re));
		else 
			i0_cerf = RooMath::ComplexErrFunc(-i0_im,i0_re);

//		RooComplex i1_cerf = RooMath::ComplexErrFunc( i0_im,i0_re);

		Double_t w_Red  = w_Exp*(i0_cerf.im() + i0_cerf.im());
		Double_t w_Blue = w_Exp*(i0_cerf.re() + i0_cerf.re());
		
		Double_t x0 = -t/tau - 0.5*Dm*Dm*sigma*sigma + 0.5*sigma*sigma/(tau*tau) ;
		Double_t y0 = -t*Dm + Dm*sigma*sigma/tau ;

		Red  = -TMath::Exp(x0)*TMath::Sin(y0) + w_Red ;
		Blue =  TMath::Exp(x0)*TMath::Cos(y0) - w_Blue ;
		if( __debug){
	                cout.precision(15);
			cout << "t = " << t << " tau = " << tau << " sigma = " << sigma << endl;

			cout << "CERF i0 = (" << i0_cerf.re() << ", " << i0_cerf.im() << ")" << endl;
//			cout << "CERF i1 = (" << i1_cerf.re() << ", " << i1_cerf.im() << ")" << endl;
			cout << "x0 = " << x0 << endl;
			cout << "y0 = " << y0 << endl;
			cout << "Pink = " << Pink << endl;
			cout << "Green = " << Green << endl;
			cout << "Red = " << Red << endl;
			cout << "Blue = " << Blue << endl;
			exit(1);
		}

/*
               TComplex t0(-1.0,-Dm*tau);
               TComplex i0 = (t*tau + sigma*sigma*t0)/(1.41421356237309515*sigma*tau);
               TComplex e0 = 1.0+Erf(i0);
               TComplex t1(-1.0,Dm*tau);
               TComplex i1 = (t*tau + sigma*sigma*t1)/(1.41421356237309515*sigma*tau);
               TComplex e1 = -1.0-Erf(i1);
               TComplex ee = TComplex::Exp(2.0*Dm*sigma*sigma*TComplex::I()/tau)*e0 + TComplex::Exp(2.0*t*Dm*TComplex::I())*e1;
               TComplex xx = -(2.0*t*tau*(1.0+TComplex::I()*Dm*tau) + sigma*sigma*(-1.0+Dm*Dm*tau*tau+TComplex::I()*2.0*Dm*tau))/(2.0*tau*tau);
               TComplex CRed = 0.25*TComplex::I()*TComplex::Exp(xx)*ee;

               TComplex bb = TComplex::Exp(2.0*Dm*sigma*sigma*TComplex::I()/tau)*e0 - TComplex::Exp(2.0*t*Dm*TComplex::I())*e1;
               TComplex CBlue = 0.25*TComplex::Exp(xx)*bb;

		if(__debug || et>=2){
			cout << "t = " << t << " tau = " << tau << " sigma = " << sigma << endl;
			cout << (t*tau + sigma*sigma*t0)/(1.41421356237309515*sigma*tau) << endl;
			cout << t*tau << endl;
			cout << (1.41421356237309515*sigma*tau) << endl;
			cout << "sigma = " << sigma << endl;
			cout << "t0 = " << t0 << endl;
			cout << "e0 = " << e0 << endl;
			cout << "t1 = " << t1 << endl;
			cout << "e1 = " << e1 << endl;
			cout << "ee = " << ee << endl;
			cout << "xx = " << xx << endl;
		//	cout << "b1 = " << b1 << endl;
			cout << "bb = " << bb << endl;

			cout << "Pink = " << Pink << endl;
			cout << "Green = " << Green << endl;
			cout << "CRed = " << CRed << endl;
			cout << "CBlue = " << CBlue << endl;
		}
		Red = CRed.Re();
		if (CRed.Im() > 0.00000000000001 ){
			cout << "Rare Red: "<< CRed << endl;
			cout << t << ' ' << et << endl;
		}
		Blue = CBlue.Re();
		if (CBlue.Im() > 0.0000000000001 ){
			cout << "Rare Blue: "<< CBlue << endl;
			cout << t << ' ' << et << endl;
		}
*/
	}

	Double_t pTauL_mTauH =2.0*(tauL*x1pC2B + tauH*x1mC2B);
	Double_t mTauL_pTauH =2.0*(tauL*x1mC2B + tauH*x1pC2B);

	Double_t f_plus_sq     = (x1pC2B*Pink + x1mC2B*Green - x2S2B*Red)/pTauL_mTauH;  // 5.8
	Double_t f_minus_sq    = (x1mC2B*Pink + x1pC2B*Green + x2S2B*Red)/mTauL_pTauH;  // 5.8
	Double_t fbar_plus_sq  = (x1pC2B*Pink + x1mC2B*Green + x2S2B*Red)/pTauL_mTauH;  // 5.7
	Double_t fbar_minus_sq = (x1mC2B*Pink + x1pC2B*Green - x2S2B*Red)/mTauL_pTauH;  // 5.7

	Double_t H = TMath::Sqrt((tauL-tauH)*(tauL-tauH)*x2S2B*x2S2B*0.25 + 4.0*tauL*tauH);

	TComplex fbar_fbar_star = ( -Blue +TComplex::I()*(-xC2B*Red + x2S2B*(Pink-Green)/4.0) )/H; //5.9
	TComplex f_f_star       = (  Blue +TComplex::I()*( xC2B*Red + x2S2B*(Pink-Green)/4.0) )/H; //5.10

	if (__debug) {
		cout << "xC2B = " << xC2B << endl;
		cout << "x2S2B = " << x2S2B << endl;
		cout << "x1pC2B = " << x1pC2B << endl;
		cout << "x1mC2B = " << x1mC2B << endl;
		cout << "H = " << H << endl;
		cout << "f_plus_sq = " << f_plus_sq << endl;
		cout << "f_minus_sq = " << f_minus_sq << endl;
		cout << "fbar_plus_sq = " << fbar_plus_sq << endl;
		cout << "fbar_minus_sq = " << fbar_minus_sq << endl;
		cout << "fbar_fbar_star = " << fbar_fbar_star << endl;
		cout << "f_f_star = " << f_f_star << endl;
	}

	/* P_B */
	P_Bb(P_B, CDAplusAplus, CDAminusAminus, CDAplusAminus, f_plus_sq, f_minus_sq, f_f_star);
	P_Bb(P_Bbar, CDAplusAplus, CDAminusAminus, CDAplusAminus, fbar_plus_sq, fbar_minus_sq, fbar_fbar_star);

	if (__debug){
		cout << "P_B = " << P_B << endl;
		cout << "P_Bbar = " << P_Bbar << endl;
	}
	/* Q_B */
	Q_Bb(Q_B, CDBB, f_minus_sq);
	Q_Bb(Q_Bbar, CDBB, fbar_minus_sq);

	if (__debug){
		cout << "Q_B = " << Q_B << endl;
		cout << "Q_Bbar = " << Q_Bbar << endl;
	}
	/* I_mu */
	I_mu(Imu, fs, delta_s);

	if (__debug){
		cout << "Imu = " << Imu << endl;
	}
	/* rho_B */
	rho_Bb(rho_B, fs, P_B, Q_B, CDAminusB, CDAplusB, f_minus_sq, f_f_star, Imu);
	rho_Bb(rho_Bbar, fs, P_Bbar, Q_Bbar, CDAminusB, CDAplusB, fbar_minus_sq, fbar_fbar_star, Imu);

	if (__debug){
		cout << "rho_B = " << rho_B << endl;
		cout << "rho_Bbar = " << rho_Bbar << endl;
	}
	/* acceptance */
	acceptance(Acceptance, ctheta, phi);

	if (__debug){
		cout << "acceptance = " << Acceptance << endl;
	}
	/* Normalization */
	Double_t IAplusXn2 = ((a0*a0+al*al)/3.54490770181103176) * e_00p0
                                + ((a0*a0+al*al)/15.8533091904240440) * e_02p0
                                - ((a0*a0-al*al)*0.109254843059207907) * e_02p2 ;

        Double_t IAminusXn2 = (ap*ap/3.54490770181103176) * e_00p0
                                + (-ap*ap/7.92665459521202198) * e_02p0 ;

        TComplex IAplusXAminus = al*TComplex(TMath::Cos(delta_l),TMath::Sin(delta_l)) * ap*TComplex(TMath::Sin(delta_p),TMath::Cos(delta_p)) * 0.218509686118415813 * e_02n1 ;

        Double_t IBXn2 = e_00p0/3.54490770181103176
                                + e_02p0/15.8533091904240440
                                - 0.109254843059207907 * e_02p2 ;
        TComplex IAminusXB = ap*TComplex(-TMath::Sin(delta_p),TMath::Cos(delta_p))* 1.01663295048409386 * e_02p1 ;
        TComplex IAplusXB  = al*TComplex(TMath::Cos(delta_l),TMath::Sin(delta_l)) * 1.01663295048409386 * e_02n2 ;

	
	Double_t IPink, IGreen, IRed, IBlue;
	IPink  = tauL;
	IGreen = tauH;
	IRed   = Dm/(Dm*Dm + (1.0/(tau*tau)));
	IBlue  = tau/(1.0 + Dm*Dm*tau*tau);

	Double_t If_plus_sq     = (x1pC2B*IPink + x1mC2B*IGreen - x2S2B*IRed)/pTauL_mTauH;  // 5.8
	Double_t If_minus_sq    = (x1mC2B*IPink + x1pC2B*IGreen + x2S2B*IRed)/mTauL_pTauH;  // 5.8
	Double_t Ifbar_plus_sq  = (x1pC2B*IPink + x1mC2B*IGreen + x2S2B*IRed)/pTauL_mTauH;  // 5.7
	Double_t Ifbar_minus_sq = (x1mC2B*IPink + x1pC2B*IGreen - x2S2B*IRed)/mTauL_pTauH;  // 5.7

	TComplex Ifbar_fbar_star = ( -IBlue +TComplex::I()*(-xC2B*Red + x2S2B*(IPink-IGreen)/4.0) )/H; //5.9
	TComplex If_f_star       = (  IBlue +TComplex::I()*( xC2B*Red + x2S2B*(IPink-IGreen)/4.0) )/H; //5.10

        Double_t IP_B = IAplusXn2*If_plus_sq
                        + IAminusXn2*If_minus_sq
                        + (IAplusXAminus*If_f_star).Re();

        Double_t IP_Bbar = IAplusXn2*Ifbar_plus_sq
                        + IAminusXn2*Ifbar_minus_sq
                        + (IAplusXAminus*Ifbar_fbar_star).Re();

        Double_t IQ_B = IBXn2*If_minus_sq;
        Double_t IQ_Bbar = IBXn2*Ifbar_minus_sq;

        Double_t I_rho_B = (1-fs)*IP_B
                                + fs*IQ_B
                                + 0.206748335783172033*(Imu*IAminusXB).Re()*If_minus_sq
                                + 0.206748335783172033*(Imu*IAplusXB*If_f_star).Re();

        Double_t I_rho_Bbar = (1-fs)*IP_Bbar
                                + fs*IQ_Bbar
                                + 0.206748335783172033*(Imu*IAminusXB).Re()*Ifbar_minus_sq
                                + 0.206748335783172033*(Imu*IAplusXB*Ifbar_fbar_star).Re();

        if (__debug){
                cout << "a0 = "  << a0 << endl;
                cout << "al = "  << al*TComplex(TMath::Cos(delta_l),TMath::Sin(delta_l))  << " |al| = " << al << " delta_l = " << delta_l << endl;
                cout << "ap = "  << ap*TComplex(TMath::Cos(delta_p),TMath::Sin(delta_p))  << " |ap| = " << ap << " delta_p = " << delta_p << endl;

                cout << "IAplusXn2 = " << IAplusXn2 << endl;
                cout << "IAminusXn2 = " << IAminusXn2 << endl;
                cout << "IAplusXAminus = " << IAplusXAminus << endl;
                cout << "IBXn2 = " << IBXn2 << endl;
                cout << "IAplusXB = " << IAplusXB << endl;
                cout << "IAminusXB = " << IAminusXB << endl;
        }
       if ( (t < -1 && et < 0.001) || (t < -2 && et < 0.01) || ( t<-4 && et < 0.1)  ){
          cout << "NaN? (" << t << ',' << et  << ") "  << rho_B << ' ' << rho_Bbar << endl;
          return 0.0;
       }

        Double_t N = (0.5-0.5*D)*I_rho_B + (0.5+0.5*D)*I_rho_Bbar ;

/*	
 	static Double_t _tau;
	if (_tau != tau) {
		_tau = tau;
		cout << "evaluate(): " << tau << endl;
		cout << rho_B << " " << rho_Bbar << " " << N << endl;
	}
*/

	Double_t result =  ( (0.5-0.5*D)*rho_B + (0.5+0.5*D)*rho_Bbar ) * Acceptance / N;

	if (result < 0.000000001 ) return 0.0;

	return result;
 } 

/*
TComplex RooBsTimeAngle::Erf(TComplex z) const{
	return Erf(z.Re(),z.Im());
}

TComplex RooBsTimeAngle::Erf(double x0, double y0) const{
**	RooComplex w = RooMath::ComplexErrFunc(y0,-x0);
	TComplex z(x0,y0);
	TComplex W(w.re(), w.im());

	cout << "Erf["<< z << "] = 1.0 - " << TComplex::Exp(-z*z) << " * " << W << endl;
	return 1.0 - TComplex::Exp(-z*z)*W;
**

	if(__debug) 
		cout << "Erf: " << x0 << " " << y0 << "I" << endl;

	if (x0 == 0 ) {
		cout << "Erf ERROR: x0==0" << endl;
		exit(1);
	}
	if (y0 < 0)
		return TComplex::Conjugate(Erf(x0,-y0));
	if (x0 < 0)
		return -Erf(-x0,-y0);

	double v0 = x0*y0;
	double x02 = x0*x0;
	long double gamma_v02n = TMath::Erfc(x0);
	double Emx02 = TMath::Exp(-x0*x0);

	long double H1 = gamma_v02n;
	long double nfact = 1;
	double k = 1.12837916709551256;
	long double a = Emx02*(1.0/nfact)*(1.0/x0);
	long double b = 1.77245385090551588*gamma_v02n;
	gamma_v02n = k*(a-b);
	
	long double h2 = gamma_v02n;

	long double v0n = v0;
	long double x02np1 = x0*x02;

	long double _H1, _h2;
	double n =0;
	while (1){
		n++;
		if (__debug) {
			cout << "n = " << n << endl;
			cout << "nfact = " << nfact << endl;
			cout << "gamma_v02n = " << gamma_v02n << endl;
			cout << "H1 = " << H1 << endl;
			cout << "h2 = " << h2 << endl;
			cout << "x02np1 = " << x02np1 << endl;
			cout << "v0n = " << v0n << endl;
			cout << endl;
		}

		gamma_v02n *= v0*v0;
		_H1=H1;
		H1 += gamma_v02n;
		
		nfact = (n+1)*nfact;
		k = 2.0/(1.77245385090551588*(2.0*n + 1));
		a = Emx02*(v0n/nfact)*(v0n/x02np1);
		b = 1.77245385090551588*gamma_v02n/(n+1);
		gamma_v02n = k*(a-b);

		_h2 = h2;
		h2 += (n+1)*gamma_v02n;

		if (_H1 == H1 && _h2 == h2)
			break;

		if ( nfact > 1e200 || fabs(v0n) > 1e200 || fabs(x02np1) > 1e200){
			cout << "Erf: ERROR z = (" << x0 << ", " << y0 << ")  t= " << t << " et="<< et<< endl;
			exit(1);
//			TComplex z(x0,y0);
//			return 1.0 - TComplex::Exp(-z*z)/(1.77245385090551588*z);
		}
	
		x02np1 *= x02;
		v0n *= v0;
	}

	double H2 = x0*h2;

	double erfc_re =  H1*TMath::Cos(2*v0) - y0*H2*TMath::Sin(2*v0);
	double erfc_im = -H1*TMath::Sin(2*v0) - y0*H2*TMath::Cos(2*v0);

	if (__debug){
		cout << "erfc = " << erfc_re << " + i " << erfc_im << endl;
		cout << "erf = " << 1.0-erfc_re << " + i " << - erfc_im << endl;
	}

	if (__debug4){
		if ( et > 0.1){
		cout.precision(15);
		int exp,exp2;
		double man = frexp(erfc_re,&exp);
		double man2 = frexp(erfc_im,&exp2);
		cout << fixed << "Test[ Erfc[" << x0 <<" +(" << y0 << " I)] , (" << man << "*2^("<< exp <<")" << "+(" << man2 << "*2^("<< exp2 <<")" << " I)) ]" << endl;
		}
	}

	return TComplex(1.0-erfc_re, -erfc_im);
}
*/

Double_t RooBsTimeAngle::HarmonicSphericalY(int l, int m, Double_t ctheta, Double_t phi) const {
        if (m==0)
                return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l+1))/(4.0*TMath::Pi()*TMath::Gamma(l+1)) )*ROOT::Math::assoc_legendre(l,0,ctheta);
	if (m>0)
                return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l-m+1))/(2.0*TMath::Pi()*TMath::Gamma(l+m+1)) )*ROOT::Math::assoc_legendre(l,m,ctheta)*TMath::Cos(m*phi)*TMath::Power(-1.0,m);
	if (m<0)
		return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l+m+1))/(2.0*TMath::Pi()*TMath::Gamma(l-m+1)) )*ROOT::Math::assoc_legendre(l,-m,ctheta)*TMath::Sin(-m*phi)*TMath::Power(-1.0,-m);
}

void RooBsTimeAngle::acceptance(Double_t &acceptance,
	Double_t ctheta, Double_t phi) const {
	acceptance = 0;

	acceptance += e_00p0*HarmonicSphericalY(0, 0, ctheta, phi);
	
	acceptance += e_01n1*HarmonicSphericalY(1,-1, ctheta, phi);
	acceptance += e_01p0*HarmonicSphericalY(1, 0, ctheta, phi);
	acceptance += e_01p1*HarmonicSphericalY(1, 1, ctheta, phi);

	acceptance += e_02n2*HarmonicSphericalY(2,-2, ctheta, phi);
	acceptance += e_02n1*HarmonicSphericalY(2,-1, ctheta, phi);
	acceptance += e_02p0*HarmonicSphericalY(2, 0, ctheta, phi);
	acceptance += e_02p1*HarmonicSphericalY(2, 1, ctheta, phi);
	acceptance += e_02p2*HarmonicSphericalY(2, 2, ctheta, phi);
}

void RooBsTimeAngle::rho_Bb(Double_t& rho_Bb,
	Double_t fs, Double_t& P_Bb, Double_t& Q_Bb, TComplex& CDAminusB, TComplex& CDAplusB, Double_t& fb_minus_sq, TComplex &fb_fb_star, TComplex& I_mu) const {    //8.19 8.20

	rho_Bb = (1-fs)*P_Bb
		 + fs*Q_Bb
		 + 0.206748335783172033*(I_mu*CDAminusB).Re()*fb_minus_sq
		 + 0.206748335783172033*(I_mu*CDAplusB*fb_fb_star).Re();
}

void RooBsTimeAngle::P_Bb(Double_t &P_Bb,
	Double_t &CDAplusAplus, Double_t &CDAminusAminus, TComplex &CDAplusAminus, Double_t &fb_plus_sq, Double_t &fb_minus_sq, TComplex &fb_fb_star) const {    //5.5 5.6

	P_Bb = 0.179049310978382253*CDAplusAplus*fb_plus_sq
		+ 0.179049310978382253*CDAminusAminus*fb_minus_sq
		+ 0.358098621956764507*(CDAplusAminus*fb_fb_star).Re();
}

void RooBsTimeAngle::Q_Bb(Double_t &Q_Bb,
	Double_t &CDBB, Double_t &fb_minus_sq) const {    //8.15 8.16

	Q_Bb = 0.0596831036594607511*CDBB*fb_minus_sq;
}

void RooBsTimeAngle::AplusK(TComplex* AplusK,
	Double_t a0, Double_t al, Double_t delta_l) const {    // 5.2

	AplusK[0] = TComplex(a0, 0.0);
	AplusK[1] = -0.707106781186547462*al*TComplex(TMath::Cos(delta_l), TMath::Sin(delta_l));
}

void RooBsTimeAngle::AminusK(TComplex &AminusK,
	Double_t ap, Double_t delta_p) const {    // 5.3

	AminusK = 0.707106781186547462*ap*TComplex(-TMath::Sin(delta_p), TMath::Cos(delta_p));
}

void RooBsTimeAngle::nhat(Double_t* nhat,
	Double_t ctheta, Double_t phi) const {    // 3.6
	nhat[0] = TMath::Sqrt(1-ctheta*ctheta)*TMath::Cos(phi);
	nhat[1] = TMath::Sqrt(1-ctheta*ctheta)*TMath::Sin(phi);
	nhat[2] = ctheta;
}

void RooBsTimeAngle::CrossDot(TComplex &CD,
	TComplex* A, TComplex* B, Double_t* n) const {
	CD = (-A[1]*n[0] + A[0]*n[1])*TComplex::Conjugate(-B[1]*n[0] + B[0]*n[1]) +
             ( A[2]*n[0] - A[0]*n[2])*TComplex::Conjugate( B[2]*n[0] - B[0]*n[2]) +
             (-A[2]*n[1] + A[1]*n[2])*TComplex::Conjugate(-B[2]*n[1] + B[1]*n[2]) ;
}

void RooBsTimeAngle::I_mu(TComplex &I_mu, Double_t fs, Double_t delta_s) const {    //8.10
	I_mu = TMath::Sqrt(fs*(1-fs))*TComplex( TMath::Cos(delta_s)*0.0032835 - TMath::Sin(delta_s)*0.3263320, 
	  	                               -TMath::Cos(delta_s)*0.3263320 - TMath::Sin(delta_s)*0.0032835  );
}

Int_t RooBsTimeAngle::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName*/) const
{
  if (matchArgs(allVars, analVars, t, cpsi, ctheta, phi)) return 1;
/*  if (matchArgs(allVars, analVars, cpsi, ctheta, phi)) return 2;
  if (matchArgs(allVars, analVars,       ctheta, phi)) return 3;
  if (matchArgs(allVars, analVars, cpsi,         phi)) return 4;
  if (matchArgs(allVars, analVars, cpsi, ctheta     )) return 5;
  if (matchArgs(allVars, analVars, cpsi             )) return 6;
  if (matchArgs(allVars, analVars,       ctheta     )) return 7;
  if (matchArgs(allVars, analVars,               phi)) return 8;
*/
 return 0;
}

Double_t RooBsTimeAngle::analyticalIntegral(Int_t code, const char* range) const
{
        if ( code == 1)
		return 1;
        return 0;
}

Int_t RooBsTimeAngle::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t staticInitOK) const
{
  if (matchArgs(directVars, generateVars, t, cpsi, ctheta, phi)) return 1;
//  if (staticInitOK)
//      if( matchArgs(directVars, generateVars, _t) ) return 2;
  return 0;
}


//_____________________________________________________________________________
void RooBsTimeAngle::initGenerator(Int_t code)
{
}

//_____________________________________________________________________________
void RooBsTimeAngle::generateEvent(Int_t code) {
    static long calls = 0;
    static long cycles = 0;
    calls++;

    Double_t max = 0.2;
    Double_t value = 0;

    Double_t G;
    while (1) {
    	cycles++;
	Double_t tauH = 2.0/((2.0/tau)-DG);
	t = - tauH * log(RooRandom::uniform(&_aleatorio));
//        t = RooRandom::uniform(&_aleatorio)*25.0 - 5.0;
        switch (code) {
            case 1:
                cpsi   = RooRandom::uniform(&_aleatorio) * (cpsi.max()   - cpsi.min())   + cpsi.min();
                ctheta = RooRandom::uniform(&_aleatorio) * (ctheta.max() - ctheta.min()) + ctheta.min();
                phi    = RooRandom::uniform(&_aleatorio) * (phi.max()    - phi.min())    + phi.min();
                if (__debug2) {
                        t = 1.28222;
                        cpsi = 0.918636;
                        ctheta = -0.4005;
                        phi = 0.485588;
                }

                if (__debug) cout << "t cpsi ctheta phi = " << t << ' ' << cpsi << ' ' << ctheta << ' ' << phi << endl;
                value = evaluate() * TMath::Exp(t/tauH);
                if(__debug2) exit(0);

                break;
            default:
                std::cout << "ERROR: generateEvent(" << code << ")" << std::endl;
                exit(1);
        }

        if ( value > max) {
                cout << "ERROR: Value > max " << value << endl;
		exit(1);
        }

        Double_t rand = RooRandom::uniform(&_aleatorio) * max;

	if (__debug) cout << rand << ' ' << value << endl;

	if (rand < value)
            break;
    }

    if (calls%5000 ==0)
	    cout << "Gen: calls = " << calls << "  cycles = " << cycles << "  cycles/calls = " << ((double)cycles)/calls  << " I = 125.663706144"<< endl;
}

