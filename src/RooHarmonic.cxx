 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooHarmonic.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include <math.h> 
 #include "TMath.h" 

 ClassImp(RooHarmonic) 

 RooHarmonic::RooHarmonic(const char *name, const char *title, 
                        RooAbsReal& _cpsi,
                        RooAbsReal& _theta,
                        RooAbsReal& _phi,
                        RooAbsReal& _C) :
   RooAbsPdf(name,title), 
   cpsi("cpsi","cpsi",this,_cpsi),
   theta("theta","theta",this,_theta),
   phi("phi","phi",this,_phi),
   C("C","C",this,_C)
 { 
 } 


 RooHarmonic::RooHarmonic(const RooHarmonic& other, const char* name) :  
   RooAbsPdf(other,name), 
   cpsi("cpsi",this,other.cpsi),
   theta("theta",this,other.theta),
   phi("phi",this,other.phi),
   C("C",this,other.C)
 { 
 } 



 Double_t RooHarmonic::evaluate() const 
 {
   Double_t result=0;
   for(int k=0;k<_max_k;k++)
   	for(int l=0;l<_max_l;l++)
		for(int m=-l;m<=l;m++)
			result += _C[k][l][m]*ROOT::Math::legendre(k,_cpsi)*HarmonicSpericalY(l,m,_theta,phi);
   return result; 
 }

 HarmonicSpericalY(l,m,ctheta,phi){
 	if (m==0)
		return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l-m+1))/(4.0*TMath::Pi()*TMath::Gamma(l+m+1)) )*ROOT::Math::assoc_legendre(l,m,ctheta);
 	if (m>0)
		return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l-m+1))/(2.0*TMath::Pi()*TMath::Gamma(l+m+1)) )*ROOT::Math::assoc_legendre(l,m,ctheta)*TMath::Cos(m*phi);
 	if (m<0)
		return TMath::Sqrt( ((2.0*l+1)*TMath::Gamma(l-m+1))/(2.0*TMath::Pi()*TMath::Gamma(l+m+1)) )*ROOT::Math::assoc_legendre(l,-m,ctheta)*TMath::Sin(m*phi);
 }



